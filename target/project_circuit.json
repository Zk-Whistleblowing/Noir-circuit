{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"11740284302864760594","abi":{"parameters":[{"name":"leafIdx","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"leafKey","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"leafNextIdx","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"leafNextKey","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"leafValue","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"global MAX_DEPTH: u32 = 32;\nuse dep::std::hash::poseidon2::Poseidon2::hash;\n\nfn verifyProof(\n    leafIdx: u32,\n    leafKey: u64,\n    leafNextIdx: u32,\n    leafNextKey: u64,\n    leafValue: Field,\n    root: Field,\n    siblings: [Field; MAX_DEPTH],\n) {\n    let mut current_hash = hash(\n        [leafKey as Field, leafNextIdx as Field, leafNextKey as Field, leafValue],\n        4,\n    );\n    let mut idx = leafIdx;\n    for i in 0..MAX_DEPTH {\n        if siblings[i] != 0 {\n            let is_right = ((idx & 1) == 0) as bool;\n            let (hash_left, hash_right) = if is_right {\n                (current_hash, siblings[i])\n            } else {\n                (siblings[i], current_hash)\n            };\n            current_hash = hash([hash_left, hash_right], 2);\n            idx >>= 1;\n        }\n    }\n    assert(current_hash == root);\n}\n\nfn verifyExclusionProof(\n    leafIdx: u32,\n    leafKey: u64,\n    leafNextIdx: u32,\n    leafNextKey: u64,\n    leafValue: Field,\n    root: Field,\n    siblings: [Field; MAX_DEPTH],\n    excludedKey: u64,\n) {\n    verifyProof(\n        leafIdx,\n        leafKey,\n        leafNextIdx,\n        leafNextKey,\n        leafValue,\n        root,\n        siblings,\n    );\n    assert(excludedKey > leafKey);\n    if leafNextIdx > 0 {\n        assert(excludedKey < leafNextKey);\n    }\n}\n\nfn verifyInsertionProof(\n    ogLeafIdx: u32,\n    ogLeafKey: u64,\n    ogLeafNextIdx: u32,\n    ogLeafNextKey: u64,\n    ogLeafValue: Field,\n    newLeafIdx: u32,\n    newLeafKey: u64,\n    newLeafValue: Field,\n    rootBefore: Field,\n    rootAfter: Field,\n    siblingsBefore: [Field; MAX_DEPTH],\n    siblingsAfterOg: [Field; MAX_DEPTH],\n    siblingsAfterNew: [Field; MAX_DEPTH],\n) {\n    // 1) All three proofs must be individually valid\n    verifyProof(\n        ogLeafIdx,\n        ogLeafKey,\n        ogLeafNextIdx,\n        ogLeafNextKey,\n        ogLeafValue,\n        rootBefore,\n        siblingsBefore,\n    );\n    verifyProof(\n        ogLeafIdx,\n        ogLeafKey,\n        newLeafIdx,\n        newLeafKey,\n        ogLeafValue,\n        rootAfter,\n        siblingsAfterOg,\n    );\n    verifyProof(\n        newLeafIdx,\n        newLeafKey,\n        ogLeafNextIdx,\n        ogLeafNextKey,\n        newLeafValue,\n        rootAfter,\n        siblingsAfterNew,\n    );\n\n    // 2) The \"after\" proofs must have equal length\n    let mut siblingsBeforeLen: u32 = MAX_DEPTH + 1;\n    let mut siblingsAfterOgLen: u32 = MAX_DEPTH + 1;\n    let mut siblingsAfterNewLen: u32 = MAX_DEPTH + 1;\n    for i in 0..MAX_DEPTH {\n        if (siblingsBeforeLen == MAX_DEPTH + 1) & (siblingsBefore[i] == 0) {\n            siblingsBeforeLen = i;\n        }\n        if (siblingsAfterOgLen == MAX_DEPTH + 1) & (siblingsAfterOg[i] == 0) {\n            siblingsAfterOgLen = i;\n        }\n        if (siblingsAfterNewLen == MAX_DEPTH + 1) & (siblingsAfterNew[i] == 0) {\n            siblingsAfterNewLen = i;\n        }\n    }\n    assert(siblingsAfterOgLen == siblingsAfterNewLen);\n    //    And the \"before\" proof's length must be either the same (no height change)\n    //    or exactly one less (height grew by 1, e.g. first insertion or crossing a power-of-two).\n    assert(\n        (siblingsBeforeLen == siblingsAfterNewLen) | (siblingsBeforeLen + 1 == siblingsAfterNewLen),\n    );\n\n    // 3) Find the first level at which the predecessor's proof changed\n    let mut diffIdx = MAX_DEPTH + 1;\n    for i in 0..MAX_DEPTH {\n        if i < siblingsAfterNewLen {\n            if (diffIdx == MAX_DEPTH + 1) & (siblingsBefore[i] != siblingsAfterOg[i]) {\n                diffIdx = i;\n            }\n        }\n    }\n    // We must see exactly one \"first\" change\n    assert(diffIdx != MAX_DEPTH + 1);\n    // And ensure nothing *before* that level changed\n    for i in 0..MAX_DEPTH {\n        if i < diffIdx {\n            assert(siblingsBefore[i] == siblingsAfterOg[i]);\n        }\n    }\n    // 4) Now recompute the \"sub-root\" of the new leaf up to diffIdx, and\n    //    check it matches the sibling that was injected into the prev-proof.\n    let mut current_hash = hash(\n        [newLeafKey as Field, ogLeafNextIdx as Field, ogLeafNextKey as Field, newLeafValue],\n        4,\n    );\n    let mut idx = newLeafIdx;\n    for i in 0..MAX_DEPTH {\n        if i < diffIdx {\n            let is_right = ((idx & 1) == 0) as bool;\n            let (hash_left, hash_right) = if is_right {\n                (current_hash, siblingsAfterNew[i])\n            } else {\n                (siblingsAfterNew[i], current_hash)\n            };\n            current_hash = hash([hash_left, hash_right], 2);\n            idx >>= 1;\n        }\n    }\n    assert(current_hash == siblingsAfterOg[diffIdx]);\n}\n\nfn main(\n    leafIdx: u32,\n    leafKey: u64,\n    leafNextIdx: u32,\n    leafNextKey: u64,\n    leafValue: Field,\n    root: Field,\n    siblings: [Field; 32],\n) {\n    verifyProof(\n        leafIdx,\n        leafKey,\n        leafNextIdx,\n        leafNextKey,\n        leafValue,\n        root,\n        siblings,\n    );\n}\n\n#[test]\nfn test_merkle_tree() {\n    verifyProof(\n        6,\n        6,\n        7,\n        7,\n        1006,\n        7420758245723695741339772407036591119149422708827218559831868837005030424306,\n        [\n            8638038457832739729317554780486517737459039859720241678260540771268785073583,\n            20875710769420856321727411154335934173213302435189610873979602997742842441139,\n            11845123360003649186639962078866747269612952657358573444480422812138068524710,\n            19163174245840510895057604832614480483787367169673967374753351720918722300633,\n            6756030518013958544030089287539615560996240983885311295876707107886417217200,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n        ],\n    );\n}\n","path":"/Users/parkssanghyeon/Desktop/web3/project_circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient"]}